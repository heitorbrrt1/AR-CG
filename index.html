<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>AR Cubagem & Picking â€” WebXR</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Barlow+Condensed:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    :root {
      --cyan:  #00c8ff;
      --red:   #ff3c3c;
      --green: #39ff6a;
      --blue:  #3a8fff;
      --panel: rgba(4, 14, 24, 0.82);
      --mono:  'Share Tech Mono', monospace;
      --ui:    'Barlow Condensed', sans-serif;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%;
      background: #080c10;
      overflow: hidden;
      font-family: var(--ui);
      color: #c8d8e8;
    }

    /* â”€â”€ Canvas must sit at z-index 0, full screen â”€â”€ */
    canvas {
      position: fixed !important;
      top: 0 !important; left: 0 !important;
      width: 100% !important; height: 100% !important;
      z-index: 0;
      display: block;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SPLASH â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #splash {
      position: fixed; inset: 0; z-index: 200;
      background: #080c10;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 18px; padding: 24px;
      transition: opacity .5s;
    }
    #splash.hidden { opacity: 0; pointer-events: none; }

    .logo-ring {
      width: 90px; height: 90px;
      border: 2px solid var(--cyan);
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 2.4rem;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%,100% { box-shadow: 0 0 0 0 rgba(0,200,255,.45); }
      50%      { box-shadow: 0 0 0 14px rgba(0,200,255,0); }
    }

    #splash h1 {
      font-family: var(--mono);
      font-size: clamp(1.1rem, 4.5vw, 1.6rem);
      color: var(--cyan);
      letter-spacing: .15em;
      text-transform: uppercase;
      text-align: center;
      line-height: 1.5;
    }
    #splash p { font-size: .88rem; opacity: .6; text-align: center; max-width: 300px; line-height: 1.5; }

    .rules-box {
      background: rgba(0,200,255,.06);
      border: 1px solid rgba(0,200,255,.2);
      padding: 10px 16px;
      font-family: var(--mono);
      font-size: .72rem;
      line-height: 1.9;
      width: 100%; max-width: 300px;
    }
    .rules-box span { color: var(--cyan); }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• AR BUTTON â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #ar-button-wrap {
      position: fixed; bottom: 40px; left: 50%;
      transform: translateX(-50%);
      z-index: 201;
    }
    #ar-button-wrap button {
      background: transparent !important;
      border: 1.5px solid var(--cyan) !important;
      color: var(--cyan) !important;
      font-family: var(--mono) !important;
      font-size: .82rem !important;
      letter-spacing: .12em !important;
      text-transform: uppercase !important;
      padding: 12px 36px !important;
      cursor: pointer !important;
      border-radius: 2px !important;
      transition: all .2s !important;
    }
    #ar-button-wrap button:hover {
      background: var(--cyan) !important;
      color: #000 !important;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DOM OVERLAY (inside AR) â•â• */
    #overlay {
      position: fixed; inset: 0;
      z-index: 1;
      pointer-events: none;
      display: none;
    }
    #overlay.active { display: block; }

    #status-bar {
      position: absolute; top: 16px; left: 50%;
      transform: translateX(-50%);
      background: var(--panel);
      border: 1px solid rgba(0,200,255,.3);
      backdrop-filter: blur(8px);
      padding: 6px 18px;
      font-family: var(--mono);
      font-size: .72rem;
      color: var(--cyan);
      letter-spacing: .06em;
      white-space: nowrap;
    }

    #hud-next {
      position: absolute; top: 56px; left: 12px;
      background: var(--panel);
      border: 1px solid rgba(0,200,255,.25);
      backdrop-filter: blur(8px);
      padding: 8px 12px;
      font-family: var(--mono);
      font-size: .68rem;
      line-height: 1.7;
      min-width: 140px;
    }
    #hud-next .label { color: var(--cyan); font-size: .6rem; text-transform: uppercase; letter-spacing: .08em; }
    .color-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 4px; vertical-align: middle; }

    #hud-stats {
      position: absolute; top: 56px; right: 12px;
      background: var(--panel);
      border: 1px solid rgba(0,200,255,.25);
      backdrop-filter: blur(8px);
      padding: 8px 12px;
      font-family: var(--mono);
      font-size: .68rem;
      line-height: 1.7;
      text-align: right;
    }
    #hud-stats .label { color: var(--cyan); font-size: .6rem; text-transform: uppercase; letter-spacing: .08em; }

    #toast {
      position: absolute; top: 46%; left: 50%;
      transform: translate(-50%, -50%);
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.15);
      backdrop-filter: blur(10px);
      padding: 10px 20px;
      font-family: var(--mono);
      font-size: .8rem;
      text-align: center;
      min-width: 220px;
      max-width: 290px;
      opacity: 0;
      transition: opacity .3s;
      line-height: 1.5;
      pointer-events: none;
    }
    #toast.show   { opacity: 1; }
    #toast.valid  { border-color: var(--green); color: var(--green); }
    #toast.error  { border-color: var(--red);   color: var(--red);   }

    #legend {
      position: absolute; bottom: 14px; left: 0; right: 0;
      display: flex; gap: 6px; justify-content: center; flex-wrap: wrap;
      padding: 0 10px;
    }
    .chip {
      background: var(--panel);
      border: 1px solid rgba(0,200,255,.2);
      backdrop-filter: blur(8px);
      padding: 4px 10px;
      font-family: var(--mono);
      font-size: .62rem;
      display: flex; align-items: center; gap: 5px;
    }
    .dot { width: 8px; height: 8px; border-radius: 50%; }

    /* Debug bar â€” always visible, helps diagnose on device */
    #debug {
      position: fixed; bottom: 0; left: 0; right: 0;
      background: rgba(0,0,0,.75);
      font-family: var(--mono);
      font-size: .58rem;
      color: #667788;
      padding: 4px 8px;
      z-index: 300;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>

  <!-- SPLASH -->
  <div id="splash">
    <div class="logo-ring">ğŸ“¦</div>
    <h1>AR Cubagem<br/>&amp; Picking</h1>
    <p>Aponte para o chÃ£o e toque para posicionar caixas. O sistema valida o empilhamento automaticamente.</p>
    <div class="rules-box">
      <span>ğŸ”´ VERMELHO</span> V &gt; X â†’ suporta tudo<br/>
      <span>ğŸŸ¢ VERDE</span> Y &lt; V &lt; X â†’ suporta ğŸŸ¢ğŸ”µ<br/>
      <span>ğŸ”µ AZUL</span> V &lt; Y â†’ sÃ³ suporta ğŸ”µ
    </div>
    <p style="font-size:.72rem;opacity:.4">Toque para fechar</p>
  </div>

  <!-- AR Button injected here by Three.js -->
  <div id="ar-button-wrap"></div>

  <!-- DOM Overlay â€” active during AR session -->
  <div id="overlay">
    <div id="status-bar">ğŸ” Procurando superfÃ­cieâ€¦</div>
    <div id="hud-next">
      <div class="label">PrÃ³xima caixa</div>
      <div id="next-info">â€”</div>
    </div>
    <div id="hud-stats">
      <div class="label">SessÃ£o</div>
      <div>Caixas: <span id="cnt-boxes">0</span></div>
      <div>Erros: <span id="cnt-errors" style="color:var(--red)">0</span></div>
    </div>
    <div id="toast"></div>
    <div id="legend">
      <div class="chip"><div class="dot" style="background:var(--red)"></div>VERMELHO V&gt;X</div>
      <div class="chip"><div class="dot" style="background:var(--green)"></div>VERDE Y&lt;V&lt;X</div>
      <div class="chip"><div class="dot" style="background:var(--blue)"></div>AZUL V&lt;Y</div>
    </div>
  </div>

  <!-- Debug bar -->
  <div id="debug">Aguardando ARâ€¦</div>

  <script type="importmap">
  {
    "imports": {
      "three":         "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    // â”€â”€â”€ Debug helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const dbgEl = document.getElementById('debug');
    function dbg(msg) {
      dbgEl.textContent = 'â¬¡ ' + msg;
      console.log('[AR]', msg);
    }

    // â”€â”€â”€ Volume thresholds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //   Dimension range: 0.20â€“0.50 m  â†’  Volume range: 0.008â€“0.125 mÂ³
    //   X = 0.075 â†’ Red  if V > X
    //   Y = 0.030 â†’ Blue if V < Y  |  Green otherwise
    const X = 0.075;
    const Y = 0.030;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RENDERER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AR BUTTON â€” WebXR hit-test only, NO legacy APIs
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const overlayEl = document.getElementById('overlay');
    const arBtn = ARButton.createButton(renderer, {
      requiredFeatures:  ['hit-test'],
      optionalFeatures:  ['dom-overlay'],
      domOverlay:        { root: overlayEl },
    });
    document.getElementById('ar-button-wrap').appendChild(arBtn);

    // Check WebXR support
    if (!('xr' in navigator)) {
      dbg('âŒ WebXR nÃ£o disponÃ­vel â€” use Chrome no Android');
    } else {
      navigator.xr.isSessionSupported('immersive-ar').then(ok => {
        dbg(ok ? 'âœ… AR suportado â€” clique START AR' : 'âŒ AR nÃ£o suportado neste dispositivo');
      });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCENE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 1.4));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(1, 3, 1);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0x334466, 0.5));

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RETICLE â€” tracks Hit Test surface (MÃ³dulo Cubagem)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const reticleGroup = new THREE.Group();
    reticleGroup.visible = false;
    reticleGroup.matrixAutoUpdate = false;
    scene.add(reticleGroup);

    const outerGeo = new THREE.RingGeometry(0.055, 0.085, 48);
    outerGeo.rotateX(-Math.PI / 2);
    reticleGroup.add(new THREE.Mesh(outerGeo,
      new THREE.MeshBasicMaterial({ color: 0x00c8ff, side: THREE.DoubleSide })));

    const innerGeo = new THREE.CircleGeometry(0.022, 24);
    innerGeo.rotateX(-Math.PI / 2);
    reticleGroup.add(new THREE.Mesh(innerGeo,
      new THREE.MeshBasicMaterial({ color: 0x00c8ff, transparent: true, opacity: .35 })));

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BOX MANAGER â€” Cubagem + Picking logic
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class BoxManager {
      constructor() {
        this.boxes      = [];
        this.errorCount = 0;
        this.boxCount   = 0;
      }

      // A. Dynamic generation with volume-based color classification
      generate() {
        const r = (a, b) => Math.random() * (b - a) + a;
        const w = r(0.20, 0.50);
        const h = r(0.20, 0.50);
        const d = r(0.20, 0.50);
        const v = w * h * d;
        let colorName, hex, emissive;
        if      (v > X) { colorName = 'red';   hex = 0xcc2222; emissive = 0x220000; }
        else if (v > Y) { colorName = 'green'; hex = 0x22aa44; emissive = 0x002210; }
        else            { colorName = 'blue';  hex = 0x2255dd; emissive = 0x001040; }
        return { w, h, d, v, colorName, hex, emissive };
      }

      // B. Stacking rules (MÃ³dulo Picking Guiado)
      // Returns true if topColor can sit on bottomColor
      canStack(topColor, bottomColor) {
        const rules = {
          red:   ['red', 'green', 'blue'],
          green: ['green', 'blue'],
          blue:  ['blue'],
        };
        return (rules[bottomColor] || []).includes(topColor);
      }

      // C. Place box â€” worldY is the Y center of the box
      place(data, worldX, worldY, worldZ) {
        const geo = new THREE.BoxGeometry(data.w, data.h, data.d);
        const mat = new THREE.MeshPhongMaterial({
          color: data.hex, emissive: data.emissive,
          shininess: 55, transparent: true, opacity: 0.88,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(worldX, worldY, worldZ);
        mesh.castShadow = mesh.receiveShadow = true;

        // Wireframe edges
        mesh.add(new THREE.LineSegments(
          new THREE.EdgesGeometry(geo),
          new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: .28 })
        ));

        // Canvas label
        mesh.add(this._label(data));
        scene.add(mesh);

        this.boxes.push({
          mesh,
          colorName: data.colorName,
          w: data.w, h: data.h, d: data.d,
          cx: worldX, cy: worldY, cz: worldZ,
        });
        this.boxCount++;
        return mesh;
      }

      // Raycast against placed boxes
      hitTest(raycaster) {
        const meshes = this.boxes.map(b => b.mesh);
        const hits   = raycaster.intersectObjects(meshes, false);
        if (!hits.length) return null;
        return this.boxes.find(b => b.mesh === hits[0].object) || null;
      }

      // Flash box red â†’ picking error visual feedback
      flashError(mesh) {
        const oc = mesh.material.color.clone();
        const oe = mesh.material.emissive.clone();
        let i = 0;
        const iv = setInterval(() => {
          i++;
          const odd = i % 2 === 1;
          mesh.material.color.set(odd ? 0xff0000 : oc);
          mesh.material.emissive.set(odd ? 0x660000 : oe);
          if (i >= 6) {
            clearInterval(iv);
            mesh.material.color.copy(oc);
            mesh.material.emissive.copy(oe);
          }
        }, 120);
      }

      _label(data) {
        const c   = document.createElement('canvas');
        c.width   = 256; c.height = 80;
        const ctx = c.getContext('2d');
        ctx.fillStyle = 'rgba(0,0,0,.5)';
        ctx.fillRect(0, 0, 256, 80);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 26px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(data.colorName.toUpperCase(), 128, 30);
        ctx.font = '17px monospace';
        ctx.fillStyle = '#aaccff';
        ctx.fillText(
          `${(data.w*100).toFixed(0)}x${(data.h*100).toFixed(0)}x${(data.d*100).toFixed(0)}cm`,
          128, 58
        );
        const spr = new THREE.Sprite(new THREE.SpriteMaterial({
          map: new THREE.CanvasTexture(c), transparent: true, opacity: .85,
        }));
        spr.scale.set(.20, .07, 1);
        spr.position.y = data.h / 2 + 0.045;
        return spr;
      }
    }

    const bm = new BoxManager();
    let nextBox = bm.generate();
    refreshHUD();

    function refreshHUD() {
      const colorCSS = { red: '#ff3c3c', green: '#39ff6a', blue: '#3a8fff' };
      document.getElementById('next-info').innerHTML =
        `<span class="color-dot" style="background:${colorCSS[nextBox.colorName]}"></span>`
        + `<b>${nextBox.colorName.toUpperCase()}</b><br/>`
        + `<span style="font-size:.63rem;opacity:.7;">`
        + `${(nextBox.w*100).toFixed(0)}x${(nextBox.h*100).toFixed(0)}x${(nextBox.d*100).toFixed(0)}cm`
        + ` V=${(nextBox.v*1e6).toFixed(0)}cc</span>`;
    }

    function updateStats() {
      document.getElementById('cnt-boxes').textContent  = bm.boxCount;
      document.getElementById('cnt-errors').textContent = bm.errorCount;
    }

    let toastTimer;
    function toast(type, msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.className   = `show ${type}`;
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => { el.className = ''; }, 2400);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HIT TEST SOURCE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let hitTestSource = null;

    renderer.xr.addEventListener('sessionstart', async () => {
      dbg('âœ… SessÃ£o AR iniciada â€” inicializando hit-testâ€¦');
      overlayEl.classList.add('active');
      document.getElementById('splash').classList.add('hidden');

      const session = renderer.xr.getSession();

      try {
        const viewerSpace = await session.requestReferenceSpace('viewer');
        hitTestSource     = await session.requestHitTestSource({ space: viewerSpace });
        dbg('âœ… Hit-test ativo â€” aponte para o chÃ£o');
      } catch (err) {
        dbg(`âŒ Hit-test erro: ${err.message}`);
      }

      session.addEventListener('end', () => {
        hitTestSource = null;
        reticleGroup.visible = false;
        overlayEl.classList.remove('active');
        dbg('SessÃ£o encerrada');
      });
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PLACEMENT HANDLER
    // Called by controller 'select' AND touchend fallback
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function handlePlacement() {
      if (!reticleGroup.visible) {
        toast('error', 'âš ï¸ Aponte para uma superfÃ­cie plana antes de tocar.');
        return;
      }

      // Ray from XR camera
      const xrCam  = renderer.xr.getCamera();
      const origin = new THREE.Vector3().setFromMatrixPosition(xrCam.matrixWorld);
      const dir    = new THREE.Vector3(0, 0, -1)
        .applyQuaternion(xrCam.quaternion)
        .normalize();
      const ray    = new THREE.Raycaster(origin, dir, 0.01, 15);

      // Check if ray hits a placed box
      const hitBox = bm.hitTest(ray);

      if (hitBox) {
        // â”€â”€ PICKING MODULE: validate stacking rule â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (bm.canStack(nextBox.colorName, hitBox.colorName)) {
          const topY = hitBox.cy + hitBox.h / 2 + nextBox.h / 2;
          bm.place(nextBox, hitBox.cx, topY, hitBox.cz);
          toast('valid',
            `âœ“ EMPILHADO\n${nextBox.colorName.toUpperCase()} â†’ ${hitBox.colorName.toUpperCase()}`);
          dbg(`Empilhou ${nextBox.colorName} sobre ${hitBox.colorName}`);
        } else {
          bm.errorCount++;
          bm.flashError(hitBox.mesh);
          toast('error',
            `âœ— ERRO DE PICKING\n${nextBox.colorName.toUpperCase()} NÃƒO pode ir sobre ${hitBox.colorName.toUpperCase()}`);
          dbg(`ERRO: ${nextBox.colorName} nÃ£o pode sobre ${hitBox.colorName}`);
        }
      } else {
        // â”€â”€ CUBING MODULE: place on real floor from hit-test pose â”€
        const pos = new THREE.Vector3().setFromMatrixPosition(reticleGroup.matrix);
        bm.place(nextBox, pos.x, pos.y + nextBox.h / 2, pos.z);
        toast('valid', `âœ“ POSICIONADO\n${nextBox.colorName.toUpperCase()} no chÃ£o`);
        dbg(`Posicionou ${nextBox.colorName} no chÃ£o`);
      }

      updateStats();
      nextBox = bm.generate();
      refreshHUD();
    }

    // Primary: XR controller select event
    const controller = renderer.xr.getController(0);
    controller.addEventListener('select', handlePlacement);
    scene.add(controller);

    // Fallback: touchend on canvas (broader device compatibility)
    renderer.domElement.addEventListener('touchend', (e) => {
      if (renderer.xr.isPresenting) {
        e.preventDefault();
        handlePlacement();
      }
    }, { passive: false });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RENDER LOOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const statusEl  = document.getElementById('status-bar');
    let surfaceFound = false;

    renderer.setAnimationLoop((timestamp, frame) => {
      if (frame && hitTestSource) {
        const refSpace = renderer.xr.getReferenceSpace();
        if (refSpace) {
          const results = frame.getHitTestResults(hitTestSource);
          if (results.length > 0) {
            const pose = results[0].getPose(refSpace);
            if (pose) {
              reticleGroup.visible = true;
              reticleGroup.matrix.fromArray(pose.transform.matrix);
              // Subtle pulse
              const s = 1 + 0.06 * Math.sin(timestamp * 0.005);
              reticleGroup.scale.set(s, 1, s);

              if (!surfaceFound) {
                surfaceFound = true;
                statusEl.textContent = 'ğŸ‘† Toque para posicionar a caixa';
                dbg('SuperfÃ­cie detectada!');
              }
            }
          } else {
            reticleGroup.visible = false;
            if (surfaceFound) {
              surfaceFound = false;
              statusEl.textContent = 'ğŸ” Procurando superfÃ­cieâ€¦';
            }
          }
        }
      }

      renderer.render(scene, camera);
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // SPLASH DISMISS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('splash').addEventListener('click', () => {
      document.getElementById('splash').classList.add('hidden');
    });

  </script>
</body>
</html>