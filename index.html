<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>AR Cubagem & Picking â€” WebXR Logistics</title>

  <!-- Google Font: Industrial/Monospace aesthetic for logistics app -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Barlow+Condensed:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    :root {
      --clr-bg:      #080c10;
      --clr-panel:   rgba(8, 18, 28, 0.88);
      --clr-border:  rgba(0, 200, 255, 0.25);
      --clr-cyan:    #00c8ff;
      --clr-red:     #ff3c3c;
      --clr-green:   #39ff6a;
      --clr-blue:    #3a8fff;
      --clr-yellow:  #ffd43b;
      --font-mono:   'Share Tech Mono', monospace;
      --font-ui:     'Barlow Condensed', sans-serif;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: var(--clr-bg);
      color: #c8d8e8;
      font-family: var(--font-ui);
      overflow: hidden;
      width: 100vw; height: 100vh;
    }

    /* â”€â”€â”€ SPLASH SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #splash {
      position: fixed; inset: 0; z-index: 100;
      background: var(--clr-bg);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 20px;
      transition: opacity .5s;
    }
    #splash h1 {
      font-family: var(--font-mono);
      font-size: clamp(1.2rem, 5vw, 1.8rem);
      color: var(--clr-cyan);
      letter-spacing: .15em;
      text-transform: uppercase;
      text-align: center;
      line-height: 1.4;
    }
    #splash p { font-size: 1rem; opacity: .65; text-align: center; max-width: 320px; }
    .scanline-logo {
      width: 96px; height: 96px;
      border: 2px solid var(--clr-cyan);
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      position: relative;
      animation: pulse-ring 2s infinite;
    }
    .scanline-logo::before {
      content: '';
      position: absolute;
      width: 72px; height: 72px;
      border: 1px dashed var(--clr-cyan);
      border-radius: 50%;
      opacity: .4;
      animation: spin 8s linear infinite;
    }
    .scanline-logo span { font-size: 2.4rem; }
    @keyframes pulse-ring {
      0%,100% { box-shadow: 0 0 0 0 rgba(0,200,255,.5); }
      50%      { box-shadow: 0 0 0 16px rgba(0,200,255,0); }
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* â”€â”€â”€ AR BUTTON (styled by Three.js, but we override) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #ar-button-container {
      position: fixed; bottom: 40px; left: 50%;
      transform: translateX(-50%);
      z-index: 50;
    }
    /* Three.js ARButton injects its own button â€” we restyle via class */
    button.ar-btn,
    #ar-button-container button {
      background: transparent !important;
      border: 1.5px solid var(--clr-cyan) !important;
      color: var(--clr-cyan) !important;
      font-family: var(--font-mono) !important;
      font-size: .85rem !important;
      letter-spacing: .12em !important;
      text-transform: uppercase !important;
      padding: 12px 32px !important;
      cursor: pointer !important;
      transition: background .2s, color .2s !important;
      border-radius: 2px !important;
    }
    #ar-button-container button:hover {
      background: var(--clr-cyan) !important;
      color: #000 !important;
    }

    /* â”€â”€â”€ DOM OVERLAY (shown while in AR) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #dom-overlay {
      position: fixed; inset: 0; pointer-events: none;
      display: none;
      z-index: 10;
    }
    #dom-overlay.active { display: block; }

    /* Top HUD */
    #hud-top {
      position: absolute; top: 16px; left: 16px; right: 16px;
      display: flex; align-items: flex-start; justify-content: space-between;
      gap: 10px;
    }
    .hud-panel {
      background: var(--clr-panel);
      border: 1px solid var(--clr-border);
      padding: 8px 14px;
      backdrop-filter: blur(8px);
      font-family: var(--font-mono);
      font-size: .72rem;
      line-height: 1.6;
      min-width: 140px;
    }
    .hud-panel .label { color: var(--clr-cyan); text-transform: uppercase; letter-spacing: .08em; }
    .hud-panel .value { font-size: 1rem; font-weight: 700; }
    #next-box-panel .swatch {
      display: inline-block; width: 10px; height: 10px;
      border-radius: 50%; margin-right: 4px; vertical-align: middle;
    }

    /* Feedback toast */
    #feedback-toast {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: var(--clr-panel);
      border: 1px solid var(--clr-border);
      padding: 12px 24px;
      font-family: var(--font-mono);
      font-size: .9rem;
      text-align: center;
      backdrop-filter: blur(10px);
      transition: opacity .35s;
      opacity: 0;
      pointer-events: none;
      min-width: 240px;
      max-width: 320px;
    }
    #feedback-toast.show { opacity: 1; }
    #feedback-toast.valid   { border-color: var(--clr-green); color: var(--clr-green); }
    #feedback-toast.invalid { border-color: var(--clr-red);   color: var(--clr-red);   }

    /* Bottom legend */
    #legend {
      position: absolute; bottom: 16px; left: 16px; right: 16px;
      display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;
    }
    .legend-chip {
      background: var(--clr-panel);
      border: 1px solid var(--clr-border);
      padding: 5px 12px;
      font-family: var(--font-mono);
      font-size: .68rem;
      display: flex; align-items: center; gap: 6px;
      backdrop-filter: blur(8px);
    }
    .dot { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }
    .dot-red   { background: var(--clr-red); }
    .dot-green { background: var(--clr-green); }
    .dot-blue  { background: var(--clr-blue); }

    /* Stats counter */
    #stats { font-size: .65rem; opacity: .5; text-align: center; margin-top: 4px; }

    /* â”€â”€â”€ Non-AR info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #desktop-info {
      position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
      font-size: .78rem; opacity: .45; text-align: center;
      font-family: var(--font-mono);
      z-index: 50;
    }
  </style>
</head>
<body>

  <!-- â•â•â• SPLASH â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="splash">
    <div class="scanline-logo"><span>ğŸ“¦</span></div>
    <h1>AR Cubagem<br/>&amp; Picking</h1>
    <p>Sistema de AuxÃ­lio Ã  Cubagem e Picking via WebXR.<br/>Aponte para uma superfÃ­cie plana e toque para empilhar caixas.</p>
  </div>

  <!-- â•â•â• AR BUTTON â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="ar-button-container"></div>

  <div id="desktop-info">Requer dispositivo com suporte a WebXR (Android + Chrome)</div>

  <!-- â•â•â• DOM OVERLAY (shown inside AR session) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="dom-overlay">

    <div id="hud-top">
      <!-- PrÃ³xima caixa a ser gerada -->
      <div class="hud-panel" id="next-box-panel">
        <div class="label">PrÃ³xima Caixa</div>
        <div class="value" id="next-box-info">â€”</div>
      </div>

      <!-- Regras de empilhamento -->
      <div class="hud-panel" style="text-align:right;">
        <div class="label">Toque para empilhar</div>
        <div style="font-size:.65rem; margin-top:4px; opacity:.75;">
          ğŸ”´ suporta tudo<br/>
          ğŸŸ¢ suporta ğŸŸ¢ğŸ”µ<br/>
          ğŸ”µ suporta ğŸ”µ
        </div>
      </div>
    </div>

    <!-- Feedback central -->
    <div id="feedback-toast"></div>

    <!-- Legenda inferior -->
    <div id="legend">
      <div class="legend-chip"><div class="dot dot-red"></div>VERMELHO V&gt;X</div>
      <div class="legend-chip"><div class="dot dot-green"></div>VERDE Y&lt;V&lt;X</div>
      <div class="legend-chip"><div class="dot dot-blue"></div>AZUL V&lt;Y</div>
    </div>
    <div id="stats">Caixas: <span id="box-count">0</span> | Erros: <span id="error-count">0</span></div>

  </div>

  <!-- â•â•â• Three.js Import Map â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <script type="importmap">
  {
    "imports": {
      "three":          "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
      "three/addons/":  "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
    }
  }
  </script>

  <!-- â•â•â• Application Script â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <script type="module">
    import * as THREE from 'three';
    import { ARButton }  from 'three/addons/webxr/ARButton.js';

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // VOLUME THRESHOLDS
    //   Dimensions: 0.2m â€“ 0.5m â†’ Volume range â‰ˆ 0.008 â€“ 0.125 mÂ³
    //   X = 0.075  â†’  Red   if V > 0.075
    //   Y = 0.030  â†’  Blue  if V < 0.030
    //              â†’  Green otherwise
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const X_THRESHOLD = 0.075;
    const Y_THRESHOLD = 0.030;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RENDERER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AR BUTTON  â€” requires 'hit-test' feature (no legacy WebVR)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const arBtn = ARButton.createButton(renderer, {
      requiredFeatures: ['hit-test'],
      optionalFeatures:  ['dom-overlay'],
      domOverlay:        { root: document.getElementById('dom-overlay') },
    });
    document.getElementById('ar-button-container').appendChild(arBtn);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCENE & CAMERA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

    // Lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x334455, 1.2);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(2, 4, 2);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const ambLight = new THREE.AmbientLight(0x203050, 0.6);
    scene.add(ambLight);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RETICLE  â€” ring that tracks Hit Test surface (floor/table)
    // This is the visual feedback for surface detection (MÃ³dulo Cubagem)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const reticleGeo = new THREE.RingGeometry(0.05, 0.08, 40);
    reticleGeo.rotateX(-Math.PI / 2);  // lay flat on ground

    const reticleMat = new THREE.MeshBasicMaterial({
      color: 0x00c8ff,
      side: THREE.DoubleSide,
    });
    const reticle = new THREE.Mesh(reticleGeo, reticleMat);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Inner dot on reticle for precision targeting
    const dotGeo = new THREE.CircleGeometry(0.02, 24);
    dotGeo.rotateX(-Math.PI / 2);
    const dotMat = new THREE.MeshBasicMaterial({ color: 0x00c8ff, opacity: .5, transparent: true });
    const dot = new THREE.Mesh(dotGeo, dotMat);
    reticle.add(dot);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BOX MANAGER â€” MÃ³dulo de Cubagem Virtual + Picking Guiado
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class BoxManager {
      constructor() {
        /** @type {Array<{mesh: THREE.Mesh, colorName: string, w: number, h: number, d: number, worldPos: THREE.Vector3}>} */
        this.boxes = [];
        this.errorCount = 0;
        this.nextBoxData = null;   // pre-generated box shown in HUD
      }

      // â”€â”€ A. Dynamic Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      generateBoxData() {
        const rnd = (min, max) => Math.random() * (max - min) + min;
        const w = rnd(0.20, 0.50);
        const h = rnd(0.20, 0.50);
        const d = rnd(0.20, 0.50);
        const volume = w * h * d;

        let colorName, hexColor, emissiveHex;
        if (volume > X_THRESHOLD) {
          colorName = 'red';   hexColor = 0xdd2020; emissiveHex = 0x330000;
        } else if (volume > Y_THRESHOLD) {
          colorName = 'green'; hexColor = 0x22cc44; emissiveHex = 0x003311;
        } else {
          colorName = 'blue';  hexColor = 0x2266ee; emissiveHex = 0x001133;
        }

        return { w, h, d, volume, colorName, hexColor, emissiveHex };
      }

      // â”€â”€ B. Stacking Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // MÃ³dulo de Picking Guiado: valida se a caixa pode ser empilhada
      canStack(topColor, bottomColor) {
        const rules = {
          red:   ['red', 'green', 'blue'],
          green: ['green', 'blue'],
          blue:  ['blue'],
        };
        return rules[bottomColor]?.includes(topColor) ?? true;
      }

      // â”€â”€ Place box at 3D world position â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      placeBox(boxData, worldPos, parentScene) {
        const geo = new THREE.BoxGeometry(boxData.w, boxData.h, boxData.d);
        const mat = new THREE.MeshPhongMaterial({
          color:     boxData.hexColor,
          emissive:  boxData.emissiveHex,
          shininess: 60,
          transparent: true,
          opacity: 0.88,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow    = true;
        mesh.receiveShadow = true;
        mesh.position.copy(worldPos);

        // Wireframe edges for industrial look
        const edges    = new THREE.EdgesGeometry(geo);
        const edgeMat  = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: .35 });
        mesh.add(new THREE.LineSegments(edges, edgeMat));

        // Label sprite (color category)
        const labelSprite = this._makeLabel(boxData.colorName.toUpperCase(),
          `W${(boxData.w*100).toFixed(0)} H${(boxData.h*100).toFixed(0)} D${(boxData.d*100).toFixed(0)}cm`);
        labelSprite.position.y = boxData.h / 2 + 0.05;
        mesh.add(labelSprite);

        parentScene.add(mesh);

        this.boxes.push({
          mesh,
          colorName: boxData.colorName,
          w: boxData.w, h: boxData.h, d: boxData.d,
          worldPos: worldPos.clone(),
        });

        return mesh;
      }

      // â”€â”€ Find which box (if any) the ray hits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      getBoxHit(raycaster) {
        const meshes = this.boxes.map(b => b.mesh);
        const hits   = raycaster.intersectObjects(meshes, false);
        if (!hits.length) return null;
        const hitMesh = hits[0].object;
        return this.boxes.find(b => b.mesh === hitMesh) || null;
      }

      // â”€â”€ Flash a mesh red to signal invalid stacking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // MÃ³dulo de Picking: feedback visual de erro
      flashError(targetMesh) {
        const origColor = targetMesh.material.color.clone();
        const origEmit  = targetMesh.material.emissive.clone();
        let   flashes   = 0;
        const interval  = setInterval(() => {
          flashes++;
          const isOdd = flashes % 2 === 1;
          targetMesh.material.color.set(isOdd ? 0xff0000 : origColor);
          targetMesh.material.emissive.set(isOdd ? 0x880000 : origEmit);
          if (flashes >= 6) {
            clearInterval(interval);
            targetMesh.material.color.copy(origColor);
            targetMesh.material.emissive.copy(origEmit);
          }
        }, 130);
      }

      // â”€â”€ Sprite text label on each box â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      _makeLabel(line1, line2) {
        const canvas  = document.createElement('canvas');
        canvas.width  = 256; canvas.height = 96;
        const ctx     = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(0, 0, 256, 96);
        ctx.fillStyle = '#ffffff';
        ctx.font      = 'bold 28px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(line1, 128, 36);
        ctx.font      = '18px monospace';
        ctx.fillStyle = '#aaccff';
        ctx.fillText(line2, 128, 66);
        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: .85 });
        const spr = new THREE.Sprite(mat);
        spr.scale.set(.22, .08, 1);
        return spr;
      }
    }

    const boxManager = new BoxManager();

    // Pre-generate first next-box and update HUD
    function refreshNextBox() {
      boxManager.nextBoxData = boxManager.generateBoxData();
      updateNextBoxHUD(boxManager.nextBoxData);
    }
    refreshNextBox();

    function updateNextBoxHUD(data) {
      const colorMap = { red: '#ff3c3c', green: '#39ff6a', blue: '#3a8fff' };
      const el = document.getElementById('next-box-info');
      el.innerHTML = `<span class="swatch" style="background:${colorMap[data.colorName]}"></span>`
        + `${data.colorName.toUpperCase()}<br/>`
        + `<span style="font-size:.65rem;opacity:.7;">`
        + `${(data.w*100).toFixed(0)}Ã—${(data.h*100).toFixed(0)}Ã—${(data.d*100).toFixed(0)}cm`
        + ` | V=${(data.volume*1e6).toFixed(0)}cc</span>`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FEEDBACK TOAST  â€” shows valid/invalid placement message
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let toastTimeout = null;
    function showFeedback(type, msg) {
      const el = document.getElementById('feedback-toast');
      el.textContent = msg;
      el.className   = `show ${type}`;
      clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => el.classList.remove('show'), 2200);
    }

    function updateStats() {
      document.getElementById('box-count').textContent   = boxManager.boxes.length;
      document.getElementById('error-count').textContent = boxManager.errorCount;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HIT-TEST SOURCE
    // The XR Hit Test detects real-world surfaces for stable placement
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let hitTestSource    = null;
    let hitTestActive    = false;

    renderer.xr.addEventListener('sessionstart', async () => {
      // Show DOM overlay
      document.getElementById('dom-overlay').classList.add('active');
      document.getElementById('splash').style.opacity = '0';
      setTimeout(() => document.getElementById('splash').style.display = 'none', 500);

      const session = renderer.xr.getSession();
      try {
        const viewerSpace = await session.requestReferenceSpace('viewer');
        hitTestSource  = await session.requestHitTestSource({ space: viewerSpace });
        hitTestActive  = true;
      } catch (e) {
        console.warn('Hit-test source failed:', e);
      }
    });

    renderer.xr.addEventListener('sessionend', () => {
      hitTestSource  = null;
      hitTestActive  = false;
      reticle.visible = false;
      document.getElementById('dom-overlay').classList.remove('active');
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONTROLLER / SELECT (TAP)
    // MÃ³dulo de Cubagem Virtual + Picking Guiado combined in one handler
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const controller = renderer.xr.getController(0);
    scene.add(controller);

    controller.addEventListener('select', () => {
      if (!reticle.visible) return;

      // Use pre-generated box data (shown in HUD)
      const boxData = boxManager.nextBoxData;

      // â”€â”€ Build a ray from the XR camera (viewer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const xrCamera  = renderer.xr.getCamera();
      const camPos    = new THREE.Vector3().setFromMatrixPosition(xrCamera.matrixWorld);
      const camDir    = new THREE.Vector3(0, 0, -1).applyMatrix4(
                          new THREE.Matrix4().extractRotation(xrCamera.matrixWorld)
                        ).normalize();
      const raycaster = new THREE.Raycaster(camPos, camDir, 0.01, 20);

      // â”€â”€ Check if ray intersects any placed box â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const hitBox = boxManager.getBoxHit(raycaster);

      if (hitBox) {
        // â”€â”€ PICKING MODULE: Validate stacking rule â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (boxManager.canStack(boxData.colorName, hitBox.colorName)) {
          // Valid stacking â€” place on top of hit box
          const topY  = hitBox.worldPos.y + hitBox.h / 2 + boxData.h / 2;
          const pos   = new THREE.Vector3(hitBox.worldPos.x, topY, hitBox.worldPos.z);
          boxManager.placeBox(boxData, pos, scene);
          showFeedback('valid',
            `âœ“ EMPILHADO\n${boxData.colorName.toUpperCase()} sobre ${hitBox.colorName.toUpperCase()}`);
        } else {
          // Invalid stacking â€” Picking error! Flash and warn.
          boxManager.errorCount++;
          boxManager.flashError(hitBox.mesh);
          showFeedback('invalid',
            `âœ— ERRO DE PICKING\n${boxData.colorName.toUpperCase()} NÃƒO pode ser empilhada sobre ${hitBox.colorName.toUpperCase()}`);
        }
      } else {
        // â”€â”€ CUBING MODULE: Place box on real-world floor surface â”€â”€
        const floorPos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
        floorPos.y    += boxData.h / 2;   // raise by half-height so bottom sits on floor
        boxManager.placeBox(boxData, floorPos, scene);
        showFeedback('valid',
          `âœ“ CAIXA POSICIONADA\n${boxData.colorName.toUpperCase()} no piso`);
      }

      updateStats();
      refreshNextBox();   // generate next box & update HUD
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ANIMATION LOOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    renderer.setAnimationLoop((timestamp, frame) => {
      if (frame) {
        const refSpace = renderer.xr.getReferenceSpace();

        // â”€â”€ Update reticle from Hit Test results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (hitTestActive && hitTestSource) {
          const results = frame.getHitTestResults(hitTestSource);
          if (results.length > 0) {
            const pose = results[0].getPose(refSpace);
            if (pose) {
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
              // Animate reticle ring scale for pulse effect
              const s = 1 + 0.08 * Math.sin(timestamp * 0.004);
              reticle.scale.set(s, 1, s);
            }
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SPLASH DISMISS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    document.getElementById('splash').addEventListener('click', () => {
      document.getElementById('splash').style.opacity = '0';
      setTimeout(() => document.getElementById('splash').style.display = 'none', 500);
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UNSUPPORTED BROWSER NOTICE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (!('xr' in navigator)) {
      document.getElementById('desktop-info').textContent =
        'âš ï¸ WebXR nÃ£o suportado neste navegador. Use Chrome no Android.';
    } else {
      navigator.xr.isSessionSupported('immersive-ar').then(supported => {
        if (!supported) {
          document.getElementById('desktop-info').textContent =
            'âš ï¸ AR nÃ£o suportado neste dispositivo.';
        } else {
          document.getElementById('desktop-info').textContent =
            'Clique em "START AR" para iniciar a sessÃ£o de Realidade Aumentada.';
        }
      });
    }

  </script>
</body>
</html>
